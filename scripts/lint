#!/bin/bash
# Unified Linter - Declarative Configuration
# Checks and optionally auto-fixes code and documentation issues
#
# Usage:
#   ./scripts/lint                # Check all (no auto-fix)
#   ./scripts/lint --fix          # Check all and auto-fix
#   ./scripts/lint docs           # Check docs only (no auto-fix)
#   ./scripts/lint docs --fix     # Check docs and auto-fix
#   ./scripts/lint rust           # Check Rust only (no auto-fix)
#   ./scripts/lint rust --fix     # Check Rust and auto-fix
#   ./scripts/lint shell          # Check shell scripts only (no auto-fix)
#   ./scripts/lint shell --fix    # Check shell scripts and auto-fix

set -e

# ============================================================================
# Configuration: Lint Definitions
# ============================================================================

# Lint definition format (associative array per lint):
#   [name]              - Display name for the lint
#   [category]          - Category: common, docs, rust, or shell
#   [check_cmd]         - Command to check (exit 0 = pass)
#   [fix_cmd]           - Command to fix (empty = cannot auto-fix)
#   [check_installed]   - Command to check if tool is installed (optional)
#   [install_hint]      - Installation hint for missing tool
#   [show_diff]         - Whether to show diff after fix (default: true)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_TYPOS=(
    [name]="Typos Check (all files)"
    [category]="common"
    [check_cmd]="typos --color=always"
    [fix_cmd]="typos --color=always --write-changes"
    [check_installed]="command -v typos"
    [install_hint]="cargo install typos-cli"
    [show_diff]="true"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_MARKDOWN=(
    [name]="Markdown Lint"
    [category]="docs"
    [check_cmd]="markdownlint --ignore node_modules --ignore target docs/ -- *.md"
    [fix_cmd]="markdownlint --fix --ignore node_modules --ignore target docs/ -- *.md"
    [check_installed]="command -v markdownlint"
    [install_hint]="npm install -g markdownlint-cli"
    [show_diff]="true"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_CLIPPY=(
    [name]="Clippy Check"
    [category]="rust"
    [check_cmd]="cargo --color=always clippy --color=always --all-targets --all-features -- -D warnings"
    [fix_cmd]="cargo --color=always clippy --color=always --fix --allow-dirty --allow-staged --all-targets --all-features -- -D warnings"
    [check_installed]="command -v cargo"
    [install_hint]="https://rustup.rs"
    [show_diff]="true"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_RUSTFMT=(
    [name]="Format Check"
    [category]="rust"
    [check_cmd]="cargo --color=always fmt --check"
    [fix_cmd]="cargo fmt"
    [check_installed]="command -v cargo"
    [install_hint]="https://rustup.rs"
    [show_diff]="true"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_TESTS=(
    [name]="Test Check"
    [category]="rust"
    [check_cmd]="cargo --color=always test --color=always --all-features"
    [fix_cmd]=""
    [check_installed]="command -v cargo"
    [install_hint]="https://rustup.rs"
    [show_diff]="false"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_RUSTDOC=(
    [name]="Rustdoc Check"
    [category]="rust"
    [check_cmd]="RUSTDOCFLAGS='-D warnings' cargo --color=always doc --color=always --no-deps --all-features"
    [fix_cmd]=""
    [check_installed]="command -v cargo"
    [install_hint]="https://rustup.rs"
    [show_diff]="false"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_SHELLCHECK=(
    [name]="Shellcheck"
    [category]="shell"
    [check_cmd]="find_shell_scripts | xargs shellcheck --color=always"
    [fix_cmd]=""
    [check_installed]="command -v shellcheck"
    [install_hint]="apt/brew install shellcheck"
    [show_diff]="false"
)

# shellcheck disable=SC2034  # Used via nameref in run_lint
declare -A LINT_SHFMT=(
    [name]="Shell Format (shfmt)"
    [category]="shell"
    [check_cmd]="find_shell_scripts | xargs shfmt -d"
    [fix_cmd]="find_shell_scripts | xargs shfmt -w"
    [check_installed]="command -v shfmt"
    [install_hint]="go install mvdan.cc/sh/v3/cmd/shfmt@latest"
    [show_diff]="true"
)

# Registry: All lints in execution order
LINT_REGISTRY=(
    LINT_TYPOS
    LINT_MARKDOWN
    LINT_CLIPPY
    LINT_RUSTFMT
    LINT_TESTS
    LINT_RUSTDOC
    LINT_SHELLCHECK
    LINT_SHFMT
)

# ============================================================================
# Colors and State
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

ERRORS=0
WARNINGS=0
MODE="check" # check or fix
TARGET=""    # empty = all, or: docs, rust, shell
INITIAL_SNAPSHOT=""

# ============================================================================
# Helper Functions
# ============================================================================

print_success() {
    echo -e "   ${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "   ${RED}✗${NC} $1"
    ERRORS=$((ERRORS + 1))
}

print_warning() {
    echo -e "   ${YELLOW}⚠${NC} $1"
    WARNINGS=$((WARNINGS + 1))
}

print_info() {
    echo -e "   ${BLUE}ℹ${NC} $1"
}

take_snapshot() {
    # Create a git stash snapshot without modifying worktree
    # Returns the stash hash (or empty if no changes to snapshot)
    git stash create 2>/dev/null || true
}

has_changes_since() {
    local snapshot="$1"
    [ -n "$snapshot" ] && ! git diff --quiet "$snapshot" 2>/dev/null
}

show_diff_since() {
    local snapshot="$1"
    local step_name="$2"
    echo -e "  ${BLUE}Changed by $step_name:${NC}"
    git --no-pager diff "$snapshot" --color=always | sed 's/^/    /'
}

# shellcheck disable=SC2329  # Invoked via eval in LINT_SHELLCHECK and LINT_SHFMT
find_shell_scripts() {
    {
        # Tracked files
        git ls-files 'scripts/*' '*.sh' '*.bash' 2>/dev/null

        # Untracked but not ignored files
        git ls-files --others --exclude-standard 'scripts/*' '*.sh' '*.bash' 2>/dev/null
    } | sort -u | while IFS= read -r file; do
        if [ -f "$file" ] && [ -r "$file" ]; then
            case "$file" in
            # .sh, .bash extensions are unconditionally shell scripts
            *.sh | *.bash)
                echo "$file"
                ;;
            *)
                # For extension-less files in scripts/, check shebang
                if head -n1 "$file" 2>/dev/null | grep -qE '^#!.*/(bash|sh|env (bash|sh))'; then
                    echo "$file"
                fi
                ;;
            esac
        fi
    done
}

# ============================================================================
# Core Lint Execution Engine
# ============================================================================

run_lint() {
    local lint_var="$1"
    local -n lint_def=$lint_var
    local lint_name="${lint_def[name]}"

    echo "${lint_name}"

    # Check if tool is installed
    if [ -n "${lint_def[check_installed]}" ]; then
        if ! eval "${lint_def[check_installed]}" &>/dev/null; then
            print_warning "Tool not installed (install with: ${lint_def[install_hint]})"
            return
        fi
    fi

    local check_cmd="${lint_def[check_cmd]}"
    local fix_cmd="${lint_def[fix_cmd]}"
    local show_diff="${lint_def[show_diff]:-true}"

    # Execute lint
    if [ "$MODE" = "fix" ] && [ -n "$fix_cmd" ]; then
        run_lint_with_fix "$lint_name" "$check_cmd" "$fix_cmd" "$show_diff"
    else
        run_lint_check_only "$lint_name" "$check_cmd" "$fix_cmd"
    fi

    echo ""
}

run_lint_check_only() {
    local lint_name="$1"
    local check_cmd="$2"
    local fix_cmd="$3"

    local output
    if output=$(eval "$check_cmd" 2>&1); then
        print_success "No issues found"
    else
        if [ -z "$fix_cmd" ]; then
            print_error "Issues found (cannot auto-fix, fix manually)"
        else
            print_error "Issues found (run with --fix to auto-fix)"
        fi
        echo "$output"
    fi
}

run_lint_with_fix() {
    local lint_name="$1"
    local check_cmd="$2"
    local fix_cmd="$3"
    local show_diff="$4"

    local snapshot
    snapshot=$(take_snapshot)

    # Run fix command (ignore output/exit code)
    eval "$fix_cmd" >/dev/null 2>&1 || true

    # Determine if fix made changes
    local fix_made_changes=false
    if has_changes_since "$snapshot"; then
        fix_made_changes=true
    fi

    # Always recheck after fix to verify final state
    local final_check_passed=true
    local final_output=""
    if ! final_output=$(eval "$check_cmd" 2>&1); then
        final_check_passed=false
    fi

    # Report results
    if [ "$fix_made_changes" = true ]; then
        if [ "$final_check_passed" = false ]; then
            print_error "Auto-fixed some issues, but problems remain:"
            echo "$final_output"
        else
            print_warning "Issues fixed automatically"
        fi
        if [ "$show_diff" = "true" ]; then
            show_diff_since "$snapshot" "$lint_name"
        fi
    else
        if [ "$final_check_passed" = false ]; then
            print_error "Issues found (cannot auto-fix):"
            echo "$final_output"
        else
            print_success "No issues found"
        fi
    fi
}

# ============================================================================
# Lint Execution by Category
# ============================================================================

run_lints_for_category() {
    local category="$1"
    local display_name="$2"

    echo "=== $display_name ==="
    echo ""

    local count=0
    for lint_var in "${LINT_REGISTRY[@]}"; do
        local -n lint=$lint_var
        if [ "${lint[category]}" = "$category" ]; then
            count=$((count + 1))
            if [ "$count" -gt 1 ] || [ "$category" != "common" ]; then
                echo -n "$count. "
            fi
            run_lint "$lint_var"
        fi
    done
}

# ============================================================================
# Summary Functions
# ============================================================================

show_changes_summary() {
    echo "=== Changes Summary ==="
    echo ""

    if [ -z "$INITIAL_SNAPSHOT" ]; then
        print_success "No changes made by linter"
    elif ! has_changes_since "$INITIAL_SNAPSHOT"; then
        print_success "No changes made by linter"
    else
        echo -e "   ${BLUE}ℹ${NC} Linter made changes to the following files:"
        echo ""
        git diff --name-only "$INITIAL_SNAPSHOT" 2>/dev/null | while IFS= read -r file; do
            echo -e "      ${YELLOW}${file}${NC}"
        done
        echo ""
        echo -e "Review changes with: ${GREEN}git diff${NC}"
    fi

    echo ""
}

print_final_summary() {
    echo "==================================="

    if [ "$ERRORS" -eq 0 ] && [ "$WARNINGS" -eq 0 ]; then
        if [ "$MODE" = "fix" ] && [ -n "$INITIAL_SNAPSHOT" ] && has_changes_since "$INITIAL_SNAPSHOT"; then
            echo -e "${GREEN}✓ All checks passed (with auto-fixes applied)${NC}"
            echo -e "   Review changes with: ${GREEN}git diff${NC}"
        else
            echo -e "${GREEN}✓ All checks passed${NC}"
        fi
        exit 0
    elif [ "$ERRORS" -eq 0 ]; then
        echo -e "${YELLOW}⚠ $WARNINGS warning(s)${NC}"
        exit 0
    else
        echo -e "${RED}✗ $ERRORS error(s), $WARNINGS warning(s)${NC}"
        exit 1
    fi
}

# ============================================================================
# Argument Parsing
# ============================================================================

parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
        docs | rust | shell)
            if [ -n "$TARGET" ]; then
                echo "Error: Multiple targets specified"
                echo ""
                show_usage
            fi
            TARGET="$1"
            shift
            ;;
        --fix)
            MODE="fix"
            shift
            ;;
        -h | --help | help)
            show_usage
            ;;
        *)
            echo "Error: Unknown argument '$1'"
            echo ""
            show_usage
            ;;
        esac
    done
}

show_usage() {
    cat <<'EOF'
Usage: ./scripts/lint [TARGET] [--fix]

Targets:
  (none)    Run all checks
  docs      Check documentation only
  rust      Check Rust code only
  shell     Check shell scripts only

Options:
  --fix     Auto-fix issues (default: check only)

Examples:
  ./scripts/lint              # Check all (no auto-fix)
  ./scripts/lint --fix        # Check and fix all
  ./scripts/lint docs         # Check docs only (no auto-fix)
  ./scripts/lint docs --fix   # Check and fix docs
  ./scripts/lint rust         # Check Rust only (no auto-fix, fast)
  ./scripts/lint rust --fix   # Check and fix Rust code
  ./scripts/lint shell        # Check shell scripts only (no auto-fix)
  ./scripts/lint shell --fix  # Check and fix shell scripts
EOF
    exit 0
}

# ============================================================================
# Main Execution
# ============================================================================

main() {
    parse_args "$@"

    # Show mode info
    if [ "$MODE" = "check" ]; then
        print_info "Mode: check only (no auto-fix)"
    else
        print_info "Mode: fix (auto-fix enabled)"
        INITIAL_SNAPSHOT=$(take_snapshot)
    fi
    echo ""

    # Run lints by target
    case "$TARGET" in
    docs)
        run_lints_for_category "common" "Common Checks"
        echo ""
        run_lints_for_category "docs" "Documentation Checks"
        ;;
    rust)
        run_lints_for_category "common" "Common Checks"
        echo ""
        run_lints_for_category "rust" "Rust Code Checks"
        ;;
    shell)
        run_lints_for_category "common" "Common Checks"
        echo ""
        run_lints_for_category "shell" "Shell Script Checks"
        ;;
    *)
        # Run all checks
        run_lints_for_category "common" "Common Checks"
        echo ""
        run_lints_for_category "docs" "Documentation Checks"
        echo ""
        run_lints_for_category "rust" "Rust Code Checks"
        echo ""
        run_lints_for_category "shell" "Shell Script Checks"
        ;;
    esac

    # Show changes summary (only if in fix mode)
    if [ "$MODE" = "fix" ]; then
        show_changes_summary
    fi

    print_final_summary
}

main "$@"
