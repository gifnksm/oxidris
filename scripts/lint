#!/bin/bash
# Unified Linter
# Checks and optionally auto-fixes code and documentation issues
#
# Usage:
#   ./scripts/lint                # Check all (no auto-fix)
#   ./scripts/lint --fix          # Check all and auto-fix
#   ./scripts/lint docs           # Check docs only (no auto-fix)
#   ./scripts/lint docs --fix     # Check docs and auto-fix
#   ./scripts/lint rust           # Check Rust only (no auto-fix)
#   ./scripts/lint rust --fix     # Check Rust and auto-fix

set -e

# ============================================================================
# Colors
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ============================================================================
# State
# ============================================================================

ERRORS=0
WARNINGS=0
TEMP_DIR=$(mktemp -d -t oxidris-lint-XXXXXX)
MODE="check" # Default mode: check (no auto-fix)
TARGET=""    # Empty = all targets

# ============================================================================
# Helper Functions
# ============================================================================

print_success() {
    echo -e "   ${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "   ${RED}✗${NC} $1"
    ERRORS=$((ERRORS + 1))
}

print_warning() {
    echo -e "   ${YELLOW}⚠${NC} $1"
    WARNINGS=$((WARNINGS + 1))
}

print_info() {
    echo -e "   ${BLUE}ℹ${NC} $1"
}

take_snapshot() {
    # Create a git stash snapshot without modifying worktree
    # Returns the stash hash (or empty if no changes to snapshot)
    # The created object is not added to stash list and will be
    # cleaned up by git gc eventually.
    git stash create 2>/dev/null || true
}

show_step_changes_if_updated() {
    # Show what changed since the snapshot, only if there are actual changes
    # Args:
    #   $1: step name (e.g., "typos", "markdownlint")
    #   $2: snapshot hash from take_snapshot
    # Returns:
    #   0 if no changes, 1 if changes were made
    local step_name="$1"
    local snapshot_hash="$2"

    # No snapshot means nothing was staged/changed before the step
    [ -z "$snapshot_hash" ] && return 1

    # Check if anything changed since snapshot
    if git diff --quiet "$snapshot_hash" 2>/dev/null; then
        return 0
    fi

    # Show the changes
    echo -e "  ${BLUE}Changed by $step_name:${NC}"
    git --no-pager diff "$snapshot_hash" --color=always | sed 's/^/    /'
    return 1
}

cleanup_temp() {
    rm -rf "$TEMP_DIR"
}

# ============================================================================
# Common Checks
# ============================================================================

check_typos() {
    echo "Typos Check"

    if ! command -v typos &>/dev/null; then
        print_warning "typos not installed (install with: cargo install typos-cli)"
        return
    fi

    local output
    if [ "$MODE" = "fix" ]; then
        local snapshot
        snapshot=$(take_snapshot)

        if typos --color=always --write-changes >/dev/null 2>&1; then
            if show_step_changes_if_updated "typos" "$snapshot"; then
                print_success "No typos found"
            else
                print_warning "Typos fixed automatically"
            fi
        else
            if show_step_changes_if_updated "typos" "$snapshot"; then
                print_error "Typos check failed"
            else
                print_error "Typos check failed (some fixes applied)"
            fi
        fi
    else
        if output=$(typos --color=always 2>&1); then
            print_success "No typos found"
        else
            print_error "Typos found (run with --fix to auto-fix)"
            echo "$output"
        fi
    fi

    echo ""
}

# ============================================================================
# Documentation Checks
# ============================================================================

check_docs_markdown() {
    echo "1. Markdown Lint"

    if ! command -v markdownlint &>/dev/null; then
        print_warning "markdownlint not installed (install with: npm install -g markdownlint-cli)"
        return
    fi

    local output
    if [ "$MODE" = "fix" ]; then
        local snapshot
        snapshot=$(take_snapshot)

        if markdownlint --fix --ignore node_modules --ignore target docs/ -- *.md >/dev/null 2>&1; then
            if show_step_changes_if_updated "markdownlint" "$snapshot"; then
                print_success "No markdown issues found"
            else
                print_warning "Markdown issues fixed automatically"
            fi
        else
            if show_step_changes_if_updated "markdownlint" "$snapshot"; then
                print_error "Markdown check failed"
            else
                print_error "Markdown check failed (some fixes applied)"
            fi
        fi
    else
        if output=$(markdownlint --ignore node_modules --ignore target docs/ -- *.md 2>&1); then
            print_success "No markdown issues found"
        else
            print_error "Markdown issues found (run with --fix to auto-fix)"
            echo "$output"
        fi
    fi

    echo ""
}

check_docs_codeblocks() {
    echo "2. Code Block Syntax"

    local errors_found=0
    local files_with_errors=()

    while IFS= read -r file; do
        if grep -n '```[a-z]' "$file" >/dev/null 2>&1; then
            files_with_errors+=("$file")
            errors_found=1
        fi
    done < <(find docs/ -name "*.md" -o -name "*.md" -maxdepth 1 -type f 2>/dev/null)

    if [ $errors_found -eq 0 ]; then
        print_success "All code blocks use path syntax"
    else
        print_error "Code blocks with language syntax found (use path syntax):"
        for file in "${files_with_errors[@]}"; do
            echo "      $file"
        done
    fi

    echo ""
}

run_docs_checks() {
    echo "=== Documentation Linter ==="
    echo ""

    if [ "$MODE" = "check" ]; then
        print_info "Mode: check only (no auto-fix)"
    else
        print_info "Mode: fix (auto-fix enabled)"
    fi
    echo ""

    check_typos
    check_docs_markdown
    check_docs_codeblocks
}

# ============================================================================
# Rust Code Checks
# ============================================================================

check_rust_clippy() {
    echo "1. Clippy Check"

    local output
    if [ "$MODE" = "fix" ]; then
        local snapshot
        snapshot=$(take_snapshot)

        # Try to auto-fix what's possible (ignore output and exit code)
        cargo --color=always clippy --color=always --fix --allow-dirty --allow-staged --all-targets --all-features -- -D warnings >/dev/null 2>&1 || true

        # Check final state without --fix to see what remains
        # Note: `cargo clippy --fix` doesn't show all warnings in its output.
        # Some non-fixable warnings (like type-complexity) aren't displayed during the --fix run,
        # even when they cause compilation to succeed (they're treated as warnings, not errors).
        # Run check mode (without --fix) to ensure all warnings are visible to the user.
        if output=$(cargo --color=always clippy --color=always --all-targets --all-features -- -D warnings 2>&1); then
            if show_step_changes_if_updated "clippy" "$snapshot"; then
                print_success "No clippy warnings"
            else
                print_warning "Clippy issues fixed automatically"
            fi
        else
            if show_step_changes_if_updated "clippy" "$snapshot"; then
                print_error "Clippy warnings remain:"
            else
                print_error "Clippy auto-fixed some issues, but warnings remain:"
            fi
            echo "$output"
        fi
    else
        # Check only, no auto-fix (fast, uses cache)
        if output=$(cargo --color=always clippy --color=always --all-targets --all-features -- -D warnings 2>&1); then
            print_success "No clippy warnings"
        else
            print_error "Clippy warnings found (run with --fix to attempt auto-fix)"
            echo "$output"
        fi
    fi

    echo ""
}

check_rust_fmt() {
    echo "2. Format Check"

    local output
    if [ "$MODE" = "fix" ]; then
        local snapshot
        snapshot=$(take_snapshot)

        if cargo fmt >/dev/null 2>&1; then
            if show_step_changes_if_updated "cargo fmt" "$snapshot"; then
                print_success "Code properly formatted"
            else
                print_warning "Code formatting issues fixed automatically"
            fi
        else
            if show_step_changes_if_updated "cargo fmt" "$snapshot"; then
                print_error "Code formatting failed"
            else
                print_error "Code formatting failed (some fixes applied)"
            fi
        fi
    else
        if output=$(cargo --color=always fmt --check 2>&1); then
            print_success "Code properly formatted"
        else
            print_error "Code formatting issues found (run with --fix to auto-fix)"
            echo "$output"
        fi
    fi

    echo ""
}

check_rust_tests() {
    echo "3. Test Check"

    local output
    if output=$(cargo --color=always test --color=always --all-features 2>&1); then
        print_success "All tests pass"
    else
        print_error "Test failures found"
        echo "$output"
    fi

    echo ""
}

check_rust_doc() {
    echo "4. Rustdoc Check"

    # Check rustdoc warnings (can't be auto-fixed, so run in both modes)
    local output
    if output=$(RUSTDOCFLAGS="-D warnings" cargo --color=always doc --color=always --no-deps --all-features 2>&1); then
        print_success "No rustdoc warnings"
    else
        print_error "Rustdoc warnings found (fix manually)"
        echo "$output"
    fi

    echo ""
}

run_rust_checks() {
    echo "=== Rust Code Linter ==="
    echo ""

    if [ "$MODE" = "check" ]; then
        print_info "Mode: check only (no auto-fix, fast with cache)"
    else
        print_info "Mode: fix (auto-fix enabled, slower)"
    fi
    echo ""

    check_typos
    check_rust_clippy
    check_rust_fmt
    check_rust_tests
    check_rust_doc
}

# ============================================================================
# Shell Script Checks
# ============================================================================

find_shell_scripts() {
    {
        # Tracked files
        git ls-files 'scripts/*' '*.sh' '*.bash' 2>/dev/null

        # Untracked but not ignored files
        git ls-files --others --exclude-standard 'scripts/*' '*.sh' '*.bash' 2>/dev/null
    } | sort -u | while IFS= read -r file; do
        if [ -f "$file" ] && [ -r "$file" ]; then
            case "$file" in
            # .sh, .bash extensions are unconditionally shell scripts
            *.sh | *.bash)
                echo "$file"
                ;;
            *)
                # For extension-less files in scripts/, check shebang
                if head -n1 "$file" 2>/dev/null | grep -qE '^#!.*/(bash|sh|env (bash|sh))'; then
                    echo "$file"
                fi
                ;;
            esac
        fi
    done
}

check_shell_shellcheck() {
    echo "1. Shellcheck"

    local files
    files=$(find_shell_scripts)

    if [ -z "$files" ]; then
        print_warning "No shell scripts found"
        return
    fi

    if ! command -v shellcheck &>/dev/null; then
        print_warning "shellcheck not installed (install with: apt/brew install shellcheck)"
        return
    fi

    # Shellcheck cannot auto-fix, runs in both modes
    local output
    if output=$(echo "$files" | xargs shellcheck --color=always 2>&1); then
        print_success "No shellcheck issues"
    else
        print_error "Shellcheck issues found (cannot auto-fix, fix manually)"
        echo "$output"
    fi

    echo ""
}

check_shell_shfmt() {
    echo "2. Shell Format (shfmt)"

    local files
    files=$(find_shell_scripts)

    if [ -z "$files" ]; then
        print_warning "No shell scripts found"
        return
    fi

    if ! command -v shfmt &>/dev/null; then
        print_warning "shfmt not installed (install with: go install mvdan.cc/sh/v3/cmd/shfmt@latest)"
        return
    fi

    local output
    if [ "$MODE" = "fix" ]; then
        local snapshot
        snapshot=$(take_snapshot)

        # Apply formatting (shfmt reads .editorconfig automatically)
        if echo "$files" | xargs shfmt -w >/dev/null 2>&1; then
            if show_step_changes_if_updated "shfmt" "$snapshot"; then
                print_success "Shell scripts properly formatted"
            else
                print_warning "Shell formatting issues fixed automatically"
            fi
        else
            if show_step_changes_if_updated "shfmt" "$snapshot"; then
                print_error "Shell formatting failed"
            else
                print_error "Shell formatting failed (some fixes applied)"
            fi
        fi
    else
        # Check differences
        if output=$(echo "$files" | xargs shfmt -d 2>&1); then
            print_success "Shell scripts properly formatted"
        else
            print_error "Shell formatting issues found (run with --fix to auto-fix)"
            echo "$output"
        fi
    fi

    echo ""
}

run_shell_checks() {
    echo "=== Shell Script Linter ==="
    echo ""

    if [ "$MODE" = "check" ]; then
        print_info "Mode: check only (no auto-fix)"
    else
        print_info "Mode: fix (auto-fix enabled for shfmt)"
    fi
    echo ""

    check_typos
    check_shell_shellcheck
    check_shell_shfmt
}

# ============================================================================
# Summary and Exit
# ============================================================================

check_script_changes() {
    echo "=== Changes Summary ==="
    echo ""

    # Check if anything changed since the initial snapshot
    if [ -z "$INITIAL_SNAPSHOT" ]; then
        print_success "No changes made by linter"
    elif git diff --quiet "$INITIAL_SNAPSHOT" 2>/dev/null; then
        print_success "No changes made by linter"
    else
        echo -e "   ${BLUE}ℹ${NC} Linter made changes to the following files:"
        echo ""
        git diff --name-only "$INITIAL_SNAPSHOT" 2>/dev/null | while IFS= read -r file; do
            echo -e "      ${YELLOW}${file}${NC}"
        done
        echo ""
        echo -e "Review changes with: ${GREEN}git diff${NC}"
    fi

    echo ""
}

print_summary() {
    echo "==================================="

    if [ "$ERRORS" -eq 0 ] && [ "$WARNINGS" -eq 0 ]; then
        if [ "$MODE" = "fix" ] && [ -n "$INITIAL_SNAPSHOT" ] && ! git diff --quiet "$INITIAL_SNAPSHOT" 2>/dev/null; then
            echo -e "${GREEN}✓ All checks passed (with auto-fixes applied)${NC}"
            echo -e "   Review changes with: ${GREEN}git diff${NC}"
        else
            echo -e "${GREEN}✓ All checks passed${NC}"
        fi
        cleanup_temp
        exit 0
    elif [ "$ERRORS" -eq 0 ]; then
        echo -e "${YELLOW}⚠ $WARNINGS warning(s)${NC}"
        cleanup_temp
        exit 0
    else
        echo -e "${RED}✗ $ERRORS error(s), $WARNINGS warning(s)${NC}"
        cleanup_temp
        exit 1
    fi
}

# ============================================================================
# Main
# ============================================================================

show_usage() {
    echo "Usage: ./scripts/lint [TARGET] [--fix]"
    echo ""
    echo "Targets:"
    echo "  (none)    Run all checks"
    echo "  docs      Check documentation only"
    echo "  rust      Check Rust code only"
    echo "  shell     Check shell scripts only"
    echo ""
    echo "Options:"
    echo "  --fix     Auto-fix issues (default: check only)"
    echo ""
    echo "Examples:"
    echo "  ./scripts/lint              # Check all (no auto-fix)"
    echo "  ./scripts/lint --fix        # Check and fix all"
    echo "  ./scripts/lint docs         # Check docs only (no auto-fix)"
    echo "  ./scripts/lint docs --fix   # Check and fix docs"
    echo "  ./scripts/lint rust         # Check Rust only (no auto-fix, fast)"
    echo "  ./scripts/lint rust --fix   # Check and fix Rust code"
    echo "  ./scripts/lint shell        # Check shell scripts only (no auto-fix)"
    echo "  ./scripts/lint shell --fix  # Check and fix shell scripts"
    exit 0
}

parse_args() {
    while [ $# -gt 0 ]; do
        case "$1" in
        docs | rust | shell)
            if [ -n "$TARGET" ]; then
                echo "Error: Multiple targets specified"
                echo ""
                show_usage
            fi
            TARGET="$1"
            shift
            ;;
        --fix)
            MODE="fix"
            shift
            ;;
        -h | --help | help)
            show_usage
            ;;
        *)
            echo "Error: Unknown argument '$1'"
            echo ""
            show_usage
            ;;
        esac
    done
}

main() {
    parse_args "$@"

    # Take initial snapshot before making any changes (for fix mode summary)
    INITIAL_SNAPSHOT=""
    if [ "$MODE" = "fix" ]; then
        INITIAL_SNAPSHOT=$(take_snapshot)
    fi

    # Run appropriate checks
    case "$TARGET" in
    docs)
        run_docs_checks
        ;;
    rust)
        run_rust_checks
        ;;
    shell)
        run_shell_checks
        ;;
    *)
        # Run all checks
        run_docs_checks
        echo ""
        run_rust_checks
        echo ""
        run_shell_checks
        ;;
    esac

    # Show changes summary (only if in fix mode)
    if [ "$MODE" = "fix" ]; then
        check_script_changes
    fi

    print_summary
}

# Trap to ensure cleanup happens even on errors
trap cleanup_temp EXIT INT TERM

main "$@"
